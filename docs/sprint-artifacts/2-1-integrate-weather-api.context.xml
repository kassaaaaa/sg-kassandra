<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>1</storyId>
    <title>Implement Weather API Poller & Caching</title>
    <status>drafted</status>
    <generatedAt>2025-12-07</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-1-integrate-weather-api.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>System</asA>
    <iWant>to fetch and cache real-time weather data from OpenWeatherMap</iWant>
    <soThat>the scheduling engine can make informed, wind-dependent decisions without exceeding API rate limits or incurring high costs</soThat>
    <tasks>
- [ ] Task 1: Database Schema Setup (AC: 3, 4)
  - [ ] Create migration for `weather_cache` table.
  - [ ] Schema: `id` (BigInt), `location` (JSON/String), `forecast_time` (TIMESTAMPTZ), `data` (JSONB), `created_at` (TIMESTAMPTZ).
  - [ ] Enable RLS (Service Role only for write, Authenticated/Service for read).
- [ ] Task 2: Environment Configuration (AC: 2)
  - [ ] Configure OpenWeatherMap API Key in Supabase Vault/Secrets.
  - [ ] Define school coordinates (Lat/Lon) as environment variables or config constants.
- [ ] Task 3: Implement Edge Function `weather-poller` (AC: 1, 2, 3, 5)
  - [ ] Initialize function using Supabase CLI.
  - [ ] Implement `fetchWeather` logic (External Call).
  - [ ] Implement `getWeather` logic (Check Cache -> Fetch if stale -> Save to Cache -> Return).
  - [ ] Handle API errors and edge cases.
- [ ] Task 4: Testing & Verification (AC: 2, 3, 5)
  - [ ] Create unit tests for the caching logic (mocking the DB and API).
  - [ ] Create an integration test invocation script.
  - [ ] Verify rate limiting protection (ensure multiple rapid calls result in 1 API hit).
    </tasks>
  </story>

  <acceptanceCriteria>
1.  **Edge Function Deployment:** A Supabase Edge Function named `weather-poller` is deployed and accessible via authenticated invocation.
2.  **External Integration:** The function successfully fetches weather data (wind speed, direction, gust) from the OpenWeatherMap One Call API 3.0 for the school's specific geographic coordinates.
3.  **Caching Mechanism:**
    - Successful API responses are stored in the `weather_cache` database table.
    - Subsequent requests within a configurable time window (default: 1 hour) return the stored data from `weather_cache` instead of calling the external API.
4.  **Data Structure:** The cached data includes a JSON snapshot of the weather conditions and a timestamp of when it was fetched.
5.  **Error Handling:** The function handles external API failures gracefully (e.g., by returning the last known good cache if available, or a structured error code).
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/fase-2-plan/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Functional Requirements</section>
        <snippet>FR004: The system shall integrate with a weather API to fetch real-time weather data for scheduling. FR030: The system must have a fallback mechanism in case the primary weather API is unavailable, such as using a secondary API or cached data.</snippet>
      </doc>
      <doc>
        <path>docs/fase-3-solution/architecture.md</path>
        <title>Architecture Document</title>
        <section>External APIs</section>
        <snippet>A resilient, testable, and efficient cache-first strategy for integrating external weather data from OpenWeatherMap.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic Technical Specification: Customer Booking and Core Scheduling</title>
        <section>Services and Modules</section>
        <snippet>weather-poller: Edge Function to fetch weather data from OpenWeatherMap, cache in DB, and serve cached data. Owner: Backend.</snippet>
      </doc>
      <doc>
        <path>docs/fase-3-solution/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 2: Customer Booking and Core Scheduling</section>
        <snippet>Story 2.1: Integrate Weather API. As a Developer, I want to create a serverless function to fetch and cache weather data from the OpenWeatherMap API, so that the system has access to real-time weather for scheduling.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>supabase/migrations/20251204000000_initial_schema.sql</path>
        <kind>database-schema</kind>
        <symbol>bookings</symbol>
        <reason>Relevant for understanding the booking entity that will be affected by weather data.</reason>
      </artifact>
      <artifact>
        <path>app/lib/db.ts</path>
        <kind>service</kind>
        <symbol>supabase</symbol>
        <reason>Provides the Supabase client instance for database interactions.</reason>
      </artifact>
    </code>
    <dependencies>
      <dependency name="@supabase/supabase-js" version="^2.86.0" />
      <dependency name="@supabase/ssr" version="^0.8.0" />
      <dependency name="zod" version="^4.1.13" />
      <dependency name="next" version="16.0.7" />
      <dependency name="react" version="19.2.0" />
      <dependency name="typescript" version="^5" />
      <dependency name="vitest" version="^4.0.15" />
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Use Deno runtime for Edge Functions.</constraint>
    <constraint>Store API keys in Supabase Vault/Secrets.</constraint>
    <constraint>Use 'service_role' client for DB writes to 'weather_cache'.</constraint>
    <constraint>Use 'zod' for validating external API responses.</constraint>
    <constraint>Enable RLS on 'weather_cache' table (Service Role only for write, Authenticated/Service for read).</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>weather-poller</name>
      <kind>Edge Function</kind>
      <signature>(POST) /weather-poller</signature>
      <path>supabase/functions/weather-poller/index.ts</path>
    </interface>
    <interface>
      <name>OpenWeatherMap One Call API 3.0</name>
      <kind>External API</kind>
      <signature>api.openweathermap.org/data/3.0/onecall</signature>
      <path>N/A</path>
    </interface>
  </interfaces>
  <tests>
    <standards>The project follows a layered testing strategy using the Vitest framework. This includes unit tests for isolated logic (e.g., caching), integration tests to verify interactions between services (e.g., Edge Functions and DB), and End-to-End (E2E) tests for critical user flows. External APIs, such as the OpenWeatherMap API, must be mocked in all automated tests to ensure deterministic and reliable results.</standards>
    <locations>
      <location type="unit">supabase/functions/weather-poller/__tests__/</location>
      <location type="integration">tests/integration/</location>
    </locations>
    <ideas>
      <idea for="AC:3">Unit test the caching logic by mocking the database and the external API; call the function twice in succession and assert that the external API is only called once.</idea>
      <idea for="AC:2,3,5">Create an integration test script that invokes the deployed Edge Function and verifies that valid data is written to the `weather_cache` table.</idea>
      <idea for="AC:3">Verify rate limiting protection by making multiple rapid calls to the function and ensuring only one outbound API call is made.</idea>
      <idea for="AC:5">Simulate a failure from the OpenWeatherMap API and assert that the function returns a structured error or a stale cache as per the defined fallback mechanism.</idea>
    </ideas>
  </tests>
</story-context>
